<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton MIDI Visualizer - High Performance</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1e 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            padding: 15px;
            text-align: center;
            background: rgba(0,0,0,0.3);
        }
        #title { font-size: 24px; margin-bottom: 10px; }
        #controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        .btn:hover { transform: scale(1.05); }
        #status { background: #dc2626; color: white; }
        #status.connected { background: #16a34a; }
        #modeBtn { background: #0ea5e9; color: white; }
        #visualCanvas {
            flex: 1;
            display: block;
            width: 100%;
        }
        #pianoContainer {
            height: 140px;
            background: rgba(0,0,0,0.4);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding: 10px;
        }
        #pianoCanvas {
            display: block;
        }
        #info {
            padding: 5px;
            text-align: center;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="title">Newton MIDI Visualizer - High Performance</div>
            <div id="controls">
                <div id="status" class="btn">‚óè MIDI Disconnected</div>
                <button id="modeBtn" class="btn">üéöÔ∏è Lanes Mode</button>
                <div id="trackInfo" style="font-size: 12px; color: #aaa;"></div>
            </div>
        </div>
        <canvas id="visualCanvas"></canvas>
        <div id="pianoContainer">
            <canvas id="pianoCanvas"></canvas>
        </div>
        <div id="info">Play MIDI to visualize ‚Ä¢ Velocity affects size & saturation</div>
    </div>

    <script>
        // Newton's color wheel
        const NEWTON_COLORS = {
            0: { r: 148, g: 0, b: 211, name: 'C-Violet' },
            1: { r: 204, g: 0, b: 102, name: 'C#' },
            2: { r: 255, g: 0, b: 0, name: 'D-Red' },
            3: { r: 255, g: 69, b: 0, name: 'D#' },
            4: { r: 255, g: 140, b: 0, name: 'E-Orange' },
            5: { r: 255, g: 255, b: 0, name: 'F-Yellow' },
            6: { r: 127, g: 255, b: 0, name: 'F#' },
            7: { r: 0, g: 255, b: 0, name: 'G-Green' },
            8: { r: 0, g: 128, b: 255, name: 'G#' },
            9: { r: 0, g: 0, b: 255, name: 'A-Blue' },
            10: { r: 75, g: 0, b: 130, name: 'A#-Indigo' },
            11: { r: 139, g: 0, b: 255, name: 'B-Violet' }
        };

        const TRACK_STYLES = [
            { blur: 4, opacity: 1.0, color: '#9333ea' },
            { blur: 6, opacity: 0.85, color: '#2563eb' },
            { blur: 8, opacity: 0.75, color: '#16a34a' },
            { blur: 10, opacity: 0.65, color: '#eab308' },
            { blur: 12, opacity: 0.60, color: '#ea580c' },
            { blur: 14, opacity: 0.55, color: '#dc2626' }
        ];

        // State
        let viewMode = 'lanes'; // 'lanes' or 'layers'
        let midiDevices = [];
        let activeNotesByTrack = {};
        let particlesByTrack = {};
        let animationFrame;

        // Canvas setup
        const visualCanvas = document.getElementById('visualCanvas');
        const visualCtx = visualCanvas.getContext('2d');
        const pianoCanvas = document.getElementById('pianoCanvas');
        const pianoCtx = pianoCanvas.getContext('2d');

        function resizeCanvases() {
            visualCanvas.width = visualCanvas.offsetWidth;
            visualCanvas.height = visualCanvas.offsetHeight;
            pianoCanvas.width = 1000;
            pianoCanvas.height = 120;
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // MIDI Setup
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(access => {
                const inputs = Array.from(access.inputs.values());
                midiDevices = inputs.map((input, idx) => ({
                    input,
                    name: input.name,
                    index: idx
                }));

                if (inputs.length > 0) {
                    document.getElementById('status').textContent = `‚úì ${inputs.length} Track(s)`;
                    document.getElementById('status').classList.add('connected');
                    document.getElementById('trackInfo').textContent = `Tracks: ${inputs.map((i, idx) => idx + 1).join(', ')}`;
                    
                    inputs.forEach((input, idx) => {
                        activeNotesByTrack[idx] = {};
                        particlesByTrack[idx] = [];
                        input.onmidimessage = (msg) => handleMIDI(msg, idx);
                        console.log(`Connected Track ${idx + 1}: ${input.name}`);
                    });
                } else {
                    document.getElementById('status').textContent = '‚úó No MIDI devices';
                }
            }).catch(err => {
                console.error('MIDI Error:', err);
                document.getElementById('status').textContent = '‚úó MIDI Error';
            });
        }

        // MIDI Handler
        function handleMIDI(message, trackIdx) {
            const [cmd, note, vel] = message.data;
            const isNoteOn = cmd >= 144 && cmd <= 159 && vel > 0;
            const isNoteOff = (cmd >= 128 && cmd <= 143) || (cmd >= 144 && cmd <= 159 && vel === 0);

            if (isNoteOn) {
                activeNotesByTrack[trackIdx][note] = vel;
                
                // Add particle
                const octave = Math.floor(note / 12) - 1;
                const noteIdx = note % 12;
                const baseColor = NEWTON_COLORS[noteIdx];
                const brightness = Math.max(0.1, octave / 10);
                const saturation = vel / 127;
                
                particlesByTrack[trackIdx].push({
                    note,
                    x: (note / 127),
                    y: 0,
                    size: 15 + (vel / 127) * 40,
                    color: getColor(baseColor, brightness, saturation),
                    vel,
                    time: 0,
                    maxTime: 2000
                });
                
            } else if (isNoteOff) {
                delete activeNotesByTrack[trackIdx][note];
            }
        }

        function getColor(base, brightness, saturation) {
            const r = Math.round(base.r * brightness * saturation + 255 * (1 - saturation) * brightness);
            const g = Math.round(base.g * brightness * saturation + 255 * (1 - saturation) * brightness);
            const b = Math.round(base.b * brightness * saturation + 255 * (1 - saturation) * brightness);
            return `rgb(${r},${g},${b})`;
        }

        // Animation Loop
        let lastTime = performance.now();
        function animate() {
            const now = performance.now();
            const dt = now - lastTime;
            lastTime = now;

            // Clear
            visualCtx.fillStyle = 'rgba(26, 26, 46, 0.1)';
            visualCtx.fillRect(0, 0, visualCanvas.width, visualCanvas.height);

            if (viewMode === 'lanes') {
                drawLanes(dt);
            } else {
                drawLayers(dt);
            }

            drawPiano();
            animationFrame = requestAnimationFrame(animate);
        }

        function drawLanes(dt) {
            const numTracks = Object.keys(particlesByTrack).length || 1;
            const laneHeight = visualCanvas.height / numTracks;

            Object.entries(particlesByTrack).forEach(([trackIdx, particles], laneIdx) => {
                const laneY = laneIdx * laneHeight;
                
                // Draw lane background
                visualCtx.fillStyle = 'rgba(255,255,255,0.02)';
                visualCtx.fillRect(0, laneY, visualCanvas.width, laneHeight);

                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.time += dt;
                    p.y = (p.time / p.maxTime);

                    if (p.time >= p.maxTime) {
                        particles.splice(i, 1);
                        continue;
                    }

                    const opacity = 1 - (p.time / p.maxTime);
                    const x = p.x * visualCanvas.width;
                    const y = laneY + p.y * laneHeight;

                    visualCtx.save();
                    visualCtx.globalAlpha = opacity;
                    visualCtx.fillStyle = p.color;
                    visualCtx.shadowBlur = p.size / 2;
                    visualCtx.shadowColor = p.color;
                    visualCtx.beginPath();
                    visualCtx.arc(x, y, p.size / 2, 0, Math.PI * 2);
                    visualCtx.fill();
                    visualCtx.restore();
                }

                // Lane label
                visualCtx.fillStyle = 'rgba(255,255,255,0.3)';
                visualCtx.font = '12px Arial';
                visualCtx.fillText(`Track ${parseInt(trackIdx) + 1}`, 10, laneY + 20);
            });
        }

        function drawLayers(dt) {
            Object.entries(particlesByTrack).forEach(([trackIdx, particles]) => {
                const style = TRACK_STYLES[trackIdx] || TRACK_STYLES[0];

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.time += dt;
                    p.y = (p.time / p.maxTime);

                    if (p.time >= p.maxTime) {
                        particles.splice(i, 1);
                        continue;
                    }

                    const opacity = (1 - (p.time / p.maxTime)) * style.opacity;
                    const x = p.x * visualCanvas.width;
                    const y = p.y * visualCanvas.height;

                    visualCtx.save();
                    visualCtx.globalAlpha = opacity;
                    visualCtx.fillStyle = p.color;
                    visualCtx.shadowBlur = style.blur * 2;
                    visualCtx.shadowColor = p.color;
                    visualCtx.filter = `blur(${style.blur}px)`;
                    visualCtx.beginPath();
                    visualCtx.arc(x, y, p.size / 2, 0, Math.PI * 2);
                    visualCtx.fill();
                    visualCtx.restore();
                }
            });
        }

        function drawPiano() {
            pianoCtx.clearRect(0, 0, pianoCanvas.width, pianoCanvas.height);
            
            const keyWidth = pianoCanvas.width / 75; // 75 white keys (C0-C10)
            const whiteHeight = pianoCanvas.height;
            const blackHeight = whiteHeight * 0.6;

            // Draw white keys
            let whiteIdx = 0;
            for (let octave = 0; octave <= 10; octave++) {
                for (let note = 0; note < 12; note++) {
                    if (octave === 10 && note > 0) break;
                    const isBlack = [1, 3, 6, 8, 10].includes(note);
                    if (isBlack) continue;

                    const midiNote = (octave + 1) * 12 + note;
                    let isActive = false;
                    let maxVel = 127;
                    
                    Object.values(activeNotesByTrack).forEach(notes => {
                        if (notes[midiNote]) {
                            isActive = true;
                            maxVel = Math.max(maxVel, notes[midiNote]);
                        }
                    });

                    const brightness = octave / 10;
                    const saturation = maxVel / 127;
                    const baseColor = NEWTON_COLORS[note];
                    const color = getColor(baseColor, brightness, saturation);

                    const x = whiteIdx * keyWidth;
                    pianoCtx.fillStyle = color;
                    pianoCtx.fillRect(x, 0, keyWidth - 1, whiteHeight);
                    
                    if (isActive) {
                        pianoCtx.strokeStyle = 'white';
                        pianoCtx.lineWidth = 2;
                        pianoCtx.strokeRect(x, 0, keyWidth - 1, whiteHeight);
                    }

                    pianoCtx.strokeStyle = 'rgba(0,0,0,0.3)';
                    pianoCtx.lineWidth = 1;
                    pianoCtx.strokeRect(x, 0, keyWidth - 1, whiteHeight);

                    whiteIdx++;
                }
            }

            // Draw black keys
            whiteIdx = 0;
            for (let octave = 0; octave <= 10; octave++) {
                for (let note = 0; note < 12; note++) {
                    if (octave === 10 && note > 0) break;
                    const isBlack = [1, 3, 6, 8, 10].includes(note);
                    
                    if (!isBlack) {
                        whiteIdx++;
                        continue;
                    }

                    const midiNote = (octave + 1) * 12 + note;
                    let isActive = false;
                    let maxVel = 127;
                    
                    Object.values(activeNotesByTrack).forEach(notes => {
                        if (notes[midiNote]) {
                            isActive = true;
                            maxVel = Math.max(maxVel, notes[midiNote]);
                        }
                    });

                    const brightness = octave / 10;
                    const saturation = maxVel / 127;
                    const baseColor = NEWTON_COLORS[note];
                    const color = getColor(baseColor, brightness, saturation);

                    const x = whiteIdx * keyWidth - keyWidth * 0.3;
                    pianoCtx.fillStyle = color;
                    pianoCtx.fillRect(x, 0, keyWidth * 0.6, blackHeight);
                    
                    if (isActive) {
                        pianoCtx.strokeStyle = 'white';
                        pianoCtx.lineWidth = 2;
                        pianoCtx.strokeRect(x, 0, keyWidth * 0.6, blackHeight);
                    }
                }
            }
        }

        // Mode toggle
        document.getElementById('modeBtn').addEventListener('click', () => {
            viewMode = viewMode === 'lanes' ? 'layers' : 'lanes';
            document.getElementById('modeBtn').textContent = 
                viewMode === 'lanes' ? 'üéöÔ∏è Lanes Mode' : 'üé≠ Layers Mode';
        });

        // Start
        animate();
    </script>
</body>
</html>