<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Chromatic MIDI Visualizer - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            --bg-color: #000;
            --text-color: #fff;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        body.light-mode {
            --bg-color: #fff;
            --text-color: #000;
        }

        #control-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-bottom: 2px solid #333;
            padding: 15px;
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            transition: transform 0.3s ease;
        }

        #control-panel.collapsed {
            transform: translateY(-100%);
        }

        #control-toggle {
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 1001;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        #control-toggle:hover {
            background: rgba(0, 0, 0, 0.95);
            border-color: #777;
        }

        body.light-mode #control-toggle {
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            border-color: #ccc;
        }

        body.light-mode #control-toggle:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #999;
        }

        #control-panel h1 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
            color: #fff;
        }

        .mode-toggle {
            display: flex;
            gap: 5px;
            background: rgba(255, 255, 255, 0.05);
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #444;
        }

        .mode-button {
            padding: 6px 16px;
            background: transparent;
            color: #aaa;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .mode-button.active {
            background: #0a84ff;
            color: #fff;
        }

        .lane-control {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid #444;
        }

        .lane-control label {
            font-weight: 600;
            font-size: 13px;
            color: #aaa;
        }

        .lane-control select {
            padding: 6px 10px;
            background: #222;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 13px;
            min-width: 180px;
            cursor: pointer;
        }

        .lane-control select:hover {
            border-color: #777;
        }

        .instrument-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .instrument-bass { background: #8b00ff; color: #fff; }
        .instrument-chords { background: #00a8ff; color: #fff; }
        .instrument-melody { background: #ff6b00; color: #fff; }
        .instrument-percussion { background: #ff0080; color: #fff; }

        .note-count {
            padding: 4px 10px;
            background: #333;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }

        .note-count.active {
            background: #0a0;
            color: #000;
        }

        #canvas-container {
            margin-top: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            transition: margin-top 0.3s ease;
        }

        #canvas-container.show-controls {
            margin-top: 100px;
            height: calc(100vh - 100px);
        }

        #canvas-container.combination-mode {
            justify-content: center;
            align-items: center;
        }

        .lane {
            flex: 1;
            position: relative;
            border-bottom: 2px solid #333;
        }

        .lane:last-child {
            border-bottom: none;
        }

        #canvas-container.combination-mode .lane {
            display: none;
        }

        .lane canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #combination-canvas {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #canvas-container.combination-mode #combination-canvas {
            display: block;
        }

        .lane-label {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 32px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.08);
            pointer-events: none;
            letter-spacing: 2px;
        }

        #no-midi-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
            font-size: 18px;
            line-height: 1.8;
            max-width: 600px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid #333;
        }

        #no-midi-message h2 {
            color: #999;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #no-midi-message.hidden {
            display: none;
        }

        .info-button {
            padding: 6px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .info-button:hover {
            background: #444;
            border-color: #777;
        }

        #info-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            overflow-y: auto;
            padding: 40px 20px;
        }

        #info-modal.visible {
            display: block;
        }

        .modal-content {
            max-width: 900px;
            margin: 0 auto;
            background: #1a1a1a;
            border-radius: 12px;
            padding: 40px;
            border: 1px solid #333;
        }

        .modal-content h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #fff;
            font-size: 24px;
        }

        .modal-content h2:first-child {
            margin-top: 0;
        }

        .modal-content p, .modal-content li {
            line-height: 1.8;
            color: #ccc;
            margin-bottom: 10px;
        }

        .modal-content ul {
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .modal-content code {
            background: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }

        .close-button {
            float: right;
            font-size: 32px;
            font-weight: 300;
            color: #666;
            cursor: pointer;
            line-height: 1;
            padding: 0 10px;
        }

        .close-button:hover {
            color: #fff;
        }

        .instrument-examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .instrument-example {
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #333;
        }

        .instrument-example h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .instrument-example p {
            font-size: 13px;
            color: #999;
        }
    </style>
</head>
<body>
    <button id="control-toggle" onclick="toggleControls()">‚öô Settings</button>

    <div id="control-panel">
        <h1>Newton's Chromatic MIDI Visualizer</h1>
        
        <div class="mode-toggle">
            <button class="mode-button active" onclick="setViewMode('lanes')">Lanes Mode</button>
            <button class="mode-button" onclick="setViewMode('combination')">Combination Mode</button>
        </div>
        
        <div class="lane-control">
            <label>Lane 1:</label>
            <select id="device-select-0">
                <option value="">Select MIDI Device...</option>
            </select>
            <select id="instrument-select-0">
                <option value="melody">Melody</option>
                <option value="bass">Bass</option>
                <option value="chords">Chords</option>
                <option value="percussion">Percussion</option>
            </select>
            <span class="instrument-badge instrument-melody" id="instrument-badge-0">MELODY</span>
            <span class="note-count" id="note-count-0">0 notes</span>
        </div>

        <div class="lane-control">
            <label>Lane 2:</label>
            <select id="device-select-1">
                <option value="">Select MIDI Device...</option>
            </select>
            <select id="instrument-select-1">
                <option value="chords">Chords</option>
                <option value="melody">Melody</option>
                <option value="bass">Bass</option>
                <option value="percussion">Percussion</option>
            </select>
            <span class="instrument-badge instrument-chords" id="instrument-badge-1">CHORDS</span>
            <span class="note-count" id="note-count-1">0 notes</span>
        </div>

        <div class="lane-control">
            <label>Lane 3:</label>
            <select id="device-select-2">
                <option value="">Select MIDI Device...</option>
            </select>
            <select id="instrument-select-2">
                <option value="bass">Bass</option>
                <option value="melody">Melody</option>
                <option value="chords">Chords</option>
                <option value="percussion">Percussion</option>
            </select>
            <span class="instrument-badge instrument-bass" id="instrument-badge-2">BASS</span>
            <span class="note-count" id="note-count-2">0 notes</span>
        </div>

        <div class="lane-control">
            <label>Theme:</label>
            <select id="theme-select" onchange="setTheme(this.value)">
                <option value="dark">Dark Mode</option>
                <option value="light">Light Mode</option>
            </select>
        </div>

        <button class="info-button" onclick="toggleInfo()">‚ÑπÔ∏è Info</button>
    </div>

    <div id="canvas-container">
        <canvas id="combination-canvas"></canvas>
        
        <div class="lane">
            <canvas id="canvas-0"></canvas>
            <div class="lane-label">LANE 1</div>
        </div>
        <div class="lane">
            <canvas id="canvas-1"></canvas>
            <div class="lane-label">LANE 2</div>
        </div>
        <div class="lane">
            <canvas id="canvas-2"></canvas>
            <div class="lane-label">LANE 3</div>
        </div>
    </div>

    <div id="no-midi-message">
        <h2>No MIDI Devices Detected</h2>
        <p>Please connect a MIDI controller or set up an IAC Driver for Logic Pro.</p>
        <p style="margin-top: 20px; font-size: 14px;">
            <strong>Using Chrome, Edge, or Opera?</strong> These browsers support Web MIDI.<br>
            Safari has limited support.
        </p>
    </div>

    <div id="info-modal">
        <div class="modal-content">
            <span class="close-button" onclick="toggleInfo()">&times;</span>
            <h2>Enhanced MIDI Visualizer</h2>
            <p>Real-time MIDI visualization with Newton's color mapping and instrument-specific rendering modes.</p>

            <h2>View Modes</h2>
            <p><strong>Lanes Mode:</strong> Three separate lanes, each with its own MIDI input and instrument visualization</p>
            <p><strong>Combination Mode:</strong> All MIDI inputs combined into an orbital visualization - each note creates a colored ring that orbits around a central nucleus. The angle of each orbit is determined by pitch, and the size/thickness is controlled by velocity.</p>

            <h2>Instrument Types</h2>
            <div class="instrument-examples">
                <div class="instrument-example" style="border-color: #8b00ff;">
                    <h3>üé∏ BASS</h3>
                    <p>Full-lane color fill based on current note. Velocity controls fade speed between notes using additive RGB color mixing.</p>
                </div>
                <div class="instrument-example" style="border-color: #00a8ff;">
                    <h3>üéπ CHORDS</h3>
                    <p>Lane split into 5 horizontal zones for chord notes. Additive color blending with 50% gradient creates harmonious color chords.</p>
                </div>
                <div class="instrument-example" style="border-color: #ff6b00;">
                    <h3>üéµ MELODY</h3>
                    <p>Large circles with soft blended edges. Enhanced from original design for prominent melodic lines.</p>
                </div>
                <div class="instrument-example" style="border-color: #ff0080;">
                    <h3>ü•Å PERCUSSION</h3>
                    <p>Explosive bursts radiating from note position. Burst size scales with velocity for dynamic visual impact.</p>
                </div>
            </div>

            <h2>Color Mapping</h2>
            <p>Based on Newton's spectrum with C=Violet (380-410nm) through B=Red (720-750nm). Colors interpolate across octaves using wavelength physics.</p>

            <h2>How to Use</h2>
            <ul>
                <li>Select view mode: Lanes or Combination</li>
                <li>Connect MIDI devices to each lane</li>
                <li>Choose instrument type for each lane</li>
                <li>Play and watch the visualization respond!</li>
            </ul>

            <h2>Additive Color Mixing</h2>
            <p>Bass and Chords modes use RGB additive color mixing:</p>
            <ul>
                <li>Multiple notes blend together like light waves</li>
                <li>Creates natural harmonic color combinations</li>
                <li>Velocity-based gradients for smooth transitions</li>
            </ul>
        </div>
    </div>

    <script>
        // ============================================================================
        // COLOR ENGINE - Newton's Chromatic Mapping
        // ============================================================================
        
        const PITCH_CLASSES = {
            0: { name: 'C', colorName: 'Violet', minWavelength: 380, maxWavelength: 410 },
            1: { name: 'C#', colorName: 'Indigo-Violet', minWavelength: 410, maxWavelength: 440 },
            2: { name: 'D', colorName: 'Indigo', minWavelength: 440, maxWavelength: 470 },
            3: { name: 'D#', colorName: 'Blue', minWavelength: 470, maxWavelength: 510 },
            4: { name: 'E', colorName: 'Blue-Cyan', minWavelength: 510, maxWavelength: 540 },
            5: { name: 'F', colorName: 'Cyan-Green', minWavelength: 540, maxWavelength: 570 },
            6: { name: 'F#', colorName: 'Green', minWavelength: 570, maxWavelength: 600 },
            7: { name: 'G', colorName: 'Yellow-Green', minWavelength: 600, maxWavelength: 630 },
            8: { name: 'G#', colorName: 'Yellow', minWavelength: 630, maxWavelength: 660 },
            9: { name: 'A', colorName: 'Orange', minWavelength: 660, maxWavelength: 690 },
            10: { name: 'A#', colorName: 'Red-Orange', minWavelength: 690, maxWavelength: 720 },
            11: { name: 'B', colorName: 'Red', minWavelength: 720, maxWavelength: 750 }
        };

        class ColorEngine {
            constructor() {
                this.colorTable = new Map();
                this.generateColorTable();
            }

            noteToWavelength(midiNote) {
                const pitchClass = midiNote % 12;
                const octave = Math.floor(midiNote / 12) - 1;
                const pitchInfo = PITCH_CLASSES[pitchClass];
                const { minWavelength, maxWavelength } = pitchInfo;
                const colorOctave = Math.max(0, Math.min(10, octave));
                return minWavelength + (colorOctave / 10) * (maxWavelength - minWavelength);
            }

            wavelengthToRGB(wavelength) {
                let r = 0, g = 0, b = 0;

                if (wavelength < 380 || wavelength > 750) {
                    return { r: 0, g: 0, b: 0, hex: '#000000' };
                }

                if (wavelength >= 380 && wavelength < 440) {
                    r = -(wavelength - 440) / (440 - 380);
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                } else if (wavelength >= 645 && wavelength <= 750) {
                    r = 1.0;
                }

                let intensity = 1.0;
                if (wavelength >= 380 && wavelength < 420) {
                    intensity = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
                } else if (wavelength >= 700 && wavelength <= 750) {
                    intensity = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);
                }

                const r255 = Math.round(Math.pow(r * intensity, 0.8) * 255);
                const g255 = Math.round(Math.pow(g * intensity, 0.8) * 255);
                const b255 = Math.round(Math.pow(b * intensity, 0.8) * 255);

                return { 
                    r: r255, 
                    g: g255, 
                    b: b255, 
                    hex: `#${r255.toString(16).padStart(2, '0')}${g255.toString(16).padStart(2, '0')}${b255.toString(16).padStart(2, '0')}`.toUpperCase()
                };
            }

            getColor(midiNote) {
                return this.colorTable.get(midiNote) || { r: 0, g: 0, b: 0, hex: '#000000' };
            }

            getNoteName(midiNote) {
                const pitchClass = midiNote % 12;
                const octave = Math.floor(midiNote / 12) - 1;
                return `${PITCH_CLASSES[pitchClass].name}${octave}`;
            }

            generateColorTable() {
                for (let midiNote = 0; midiNote <= 127; midiNote++) {
                    const wavelength = this.noteToWavelength(midiNote);
                    const color = this.wavelengthToRGB(wavelength);
                    this.colorTable.set(midiNote, color);
                }
            }

            // Additive RGB color mixing
            mixColors(colors, weights = null) {
                if (colors.length === 0) return { r: 0, g: 0, b: 0 };
                
                let totalR = 0, totalG = 0, totalB = 0;
                const w = weights || colors.map(() => 1);
                const totalWeight = w.reduce((a, b) => a + b, 0);

                colors.forEach((color, i) => {
                    const weight = w[i] / totalWeight;
                    totalR += color.r * weight;
                    totalG += color.g * weight;
                    totalB += color.b * weight;
                });

                return {
                    r: Math.min(255, Math.round(totalR)),
                    g: Math.min(255, Math.round(totalG)),
                    b: Math.min(255, Math.round(totalB))
                };
            }
        }

        const colorEngine = new ColorEngine();

        // ============================================================================
        // ENHANCED MIDI VISUALIZER
        // ============================================================================

        class MIDIVisualizer {
            constructor() {
                this.midiAccess = null;
                this.viewMode = 'lanes'; // 'lanes' or 'combination'
                this.theme = 'dark'; // 'dark' or 'light'
                this.lanes = [
                    { activeNotes: new Map(), connectedDevice: null, canvas: null, ctx: null, instrument: 'melody', prevColor: null, fadeStartTime: null },
                    { activeNotes: new Map(), connectedDevice: null, canvas: null, ctx: null, instrument: 'chords', prevColor: null, fadeStartTime: null },
                    { activeNotes: new Map(), connectedDevice: null, canvas: null, ctx: null, instrument: 'bass', prevColor: null, fadeStartTime: null }
                ];
                this.combinationCanvas = null;
                this.combinationCtx = null;
                this.devices = [];
                this.decayTime = 1000;
                
                this.init();
            }

            async init() {
                // Setup lane canvases
                this.lanes.forEach((lane, index) => {
                    lane.canvas = document.getElementById(`canvas-${index}`);
                    lane.ctx = lane.canvas.getContext('2d');
                    this.resizeCanvas(index);
                    
                    // Instrument select handler
                    const instrumentSelect = document.getElementById(`instrument-select-${index}`);
                    instrumentSelect.value = lane.instrument;
                    instrumentSelect.onchange = () => {
                        lane.instrument = instrumentSelect.value;
                        this.updateInstrumentBadge(index);
                    };
                    this.updateInstrumentBadge(index);
                });

                // Setup combination canvas
                this.combinationCanvas = document.getElementById('combination-canvas');
                this.combinationCtx = this.combinationCanvas.getContext('2d');
                this.resizeCombinationCanvas();

                window.addEventListener('resize', () => {
                    this.lanes.forEach((_, index) => this.resizeCanvas(index));
                    this.resizeCombinationCanvas();
                });

                // Request MIDI access
                if (navigator.requestMIDIAccess) {
                    try {
                        this.midiAccess = await navigator.requestMIDIAccess();
                        this.updateDeviceList();
                        this.midiAccess.onstatechange = () => this.updateDeviceList();
                        this.hideNoMidiMessage();
                    } catch (err) {
                        alert('MIDI access denied. Please allow MIDI access in your browser.');
                    }
                } else {
                    alert('Web MIDI API not supported. Please use Chrome, Edge, or Opera.');
                }

                this.animate();
            }

            resizeCanvas(laneIndex) {
                const canvas = this.lanes[laneIndex].canvas;
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            resizeCombinationCanvas() {
                this.combinationCanvas.width = this.combinationCanvas.offsetWidth;
                this.combinationCanvas.height = this.combinationCanvas.offsetHeight;
            }

            updateInstrumentBadge(laneIndex) {
                const instrument = this.lanes[laneIndex].instrument;
                const badge = document.getElementById(`instrument-badge-${laneIndex}`);
                badge.className = `instrument-badge instrument-${instrument}`;
                badge.textContent = instrument.toUpperCase();
            }

            updateDeviceList() {
                this.devices = [];
                this.midiAccess.inputs.forEach(input => {
                    this.devices.push({ id: input.id, name: input.name || 'Unknown Device' });
                });

                for (let i = 0; i < 3; i++) {
                    const select = document.getElementById(`device-select-${i}`);
                    const currentValue = select.value;
                    
                    select.innerHTML = '<option value="">Select MIDI Device...</option>';
                    this.devices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.id;
                        option.textContent = device.name;
                        select.appendChild(option);
                    });
                    
                    select.value = currentValue;
                    select.onchange = () => this.connectDeviceToLane(select.value, i);
                }

                if (this.devices.length > 0) {
                    this.hideNoMidiMessage();
                } else {
                    this.showNoMidiMessage();
                }
            }

            connectDeviceToLane(deviceId, laneIndex) {
                if (!this.midiAccess) return;

                const currentDevice = this.lanes[laneIndex].connectedDevice;
                if (currentDevice) {
                    const input = this.midiAccess.inputs.get(currentDevice);
                    if (input) input.onmidimessage = null;
                }

                if (deviceId) {
                    const input = this.midiAccess.inputs.get(deviceId);
                    if (input) {
                        input.onmidimessage = (message) => this.handleMIDIMessage(message, laneIndex);
                        this.lanes[laneIndex].connectedDevice = deviceId;
                    }
                } else {
                    this.lanes[laneIndex].connectedDevice = null;
                }
            }

            handleMIDIMessage(message, laneIndex) {
                const [status, note, velocity] = message.data;
                const command = status & 0xf0;

                if (command === 0x90 && velocity > 0) {
                    this.handleNoteOn(note, velocity, laneIndex);
                } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
                    this.handleNoteOff(note, laneIndex);
                }
            }

            handleNoteOn(midiNote, velocity, laneIndex) {
                const color = colorEngine.getColor(midiNote);
                
                const noteData = {
                    midiNote,
                    velocity,
                    color,
                    startTime: performance.now(),
                    releaseTime: null,
                    laneIndex
                };
                
                this.lanes[laneIndex].activeNotes.set(midiNote, noteData);
                this.updateNoteCount(laneIndex);
                
                console.log(`Note ON: ${colorEngine.getNoteName(midiNote)} in Lane ${laneIndex + 1}, Mode: ${this.viewMode}`);
            }

            handleNoteOff(midiNote, laneIndex) {
                const note = this.lanes[laneIndex].activeNotes.get(midiNote);
                if (note) {
                    note.releaseTime = performance.now();
                    console.log(`Note OFF: ${colorEngine.getNoteName(midiNote)} in Lane ${laneIndex + 1}`);
                }
            }

            updateNoteCount(laneIndex) {
                const count = this.lanes[laneIndex].activeNotes.size;
                const element = document.getElementById(`note-count-${laneIndex}`);
                element.textContent = `${count} note${count !== 1 ? 's' : ''}`;
                element.classList.toggle('active', count > 0);
                
                // Log for debugging
                if (this.viewMode === 'combination') {
                    const totalNotes = this.lanes.reduce((sum, lane) => sum + lane.activeNotes.size, 0);
                    console.log(`Total active notes: ${totalNotes}`);
                }
            }

            // ============================================================================
            // RENDERING - Instrument-specific visualizations
            // ============================================================================

            renderBass(lane, ctx, canvas, now) {
                const bgColor = this.theme === 'dark' ? '#000' : '#fff';
                
                // Get most recent note (bass lines are typically monophonic)
                let currentNote = null;
                let latestTime = 0;
                
                lane.activeNotes.forEach(note => {
                    if (!note.releaseTime && note.startTime > latestTime) {
                        currentNote = note;
                        latestTime = note.startTime;
                    }
                });

                if (currentNote) {
                    const targetColor = currentNote.color;
                    
                    // Initialize previous color if needed
                    if (!lane.prevColor) {
                        lane.prevColor = targetColor;
                        lane.fadeStartTime = now;
                    }

                    // Calculate fade progress based on velocity (higher velocity = longer fade)
                    const fadeSpeed = 500 + (currentNote.velocity / 127) * 1500; // 500-2000ms
                    const fadeProgress = Math.min(1, (now - lane.fadeStartTime) / fadeSpeed);

                    // Additive RGB mixing for gradient
                    const r = Math.round(lane.prevColor.r + (targetColor.r - lane.prevColor.r) * fadeProgress);
                    const g = Math.round(lane.prevColor.g + (targetColor.g - lane.prevColor.g) * fadeProgress);
                    const b = Math.round(lane.prevColor.b + (targetColor.b - lane.prevColor.b) * fadeProgress);

                    // Fill entire lane with color
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Update if fade complete
                    if (fadeProgress >= 1) {
                        lane.prevColor = targetColor;
                        lane.fadeStartTime = now;
                    }
                } else {
                    // Fade to background color when no notes
                    if (lane.prevColor) {
                        const fadeSpeed = 1000;
                        const fadeProgress = Math.min(1, (now - (lane.fadeStartTime || now)) / fadeSpeed);
                        const r = Math.round(lane.prevColor.r * (1 - fadeProgress));
                        const g = Math.round(lane.prevColor.g * (1 - fadeProgress));
                        const b = Math.round(lane.prevColor.b * (1 - fadeProgress));
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        if (fadeProgress >= 1) {
                            lane.prevColor = null;
                        }
                    } else {
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }
            }

            renderChords(lane, ctx, canvas, now) {
                const bgColor = this.theme === 'dark' ? '#000' : '#fff';
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Get active notes sorted by pitch
                const activeNotes = Array.from(lane.activeNotes.values())
                    .filter(note => !note.releaseTime || (now - note.releaseTime < this.decayTime))
                    .sort((a, b) => a.midiNote - b.midiNote);

                if (activeNotes.length === 0) return;

                // 5 horizontal zones: top intermediate, top main, middle, bottom main, bottom intermediate
                const zones = [0.1, 0.3, 0.5, 0.7, 0.9]; // Y positions (0-1)
                
                activeNotes.forEach((note, index) => {
                    let opacity = 1.0;
                    if (note.releaseTime) {
                        opacity = Math.max(0, 1 - (now - note.releaseTime) / this.decayTime);
                        if (opacity <= 0) {
                            lane.activeNotes.delete(note.midiNote);
                            return;
                        }
                    }

                    // Assign note to zone (main zones for first 3 notes, intermediates for extras)
                    let zoneY;
                    if (activeNotes.length === 1) {
                        zoneY = zones[2]; // Middle
                    } else if (activeNotes.length === 2) {
                        zoneY = zones[index === 0 ? 1 : 3]; // Top and bottom main
                    } else {
                        zoneY = zones[Math.min(index, zones.length - 1)];
                    }

                    const y = canvas.height * zoneY;
                    const zoneHeight = canvas.height * 0.15;

                    // Create gradient with 50% blend
                    const gradient = ctx.createLinearGradient(0, y - zoneHeight, 0, y + zoneHeight);
                    gradient.addColorStop(0, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, 0)`);
                    gradient.addColorStop(0.5, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${opacity})`);
                    gradient.addColorStop(1, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, y - zoneHeight, canvas.width, zoneHeight * 2);
                });
            }

            renderMelody(lane, ctx, canvas, now) {
                const bgColor = this.theme === 'dark' ? '#000' : '#fff';
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                lane.activeNotes.forEach((note) => {
                    let opacity = 1.0;
                    if (note.releaseTime) {
                        opacity = Math.max(0, 1 - (now - note.releaseTime) / this.decayTime);
                        if (opacity <= 0) {
                            lane.activeNotes.delete(note.midiNote);
                            return;
                        }
                    }

                    const x = (note.midiNote / 127) * canvas.width;
                    const y = canvas.height / 2;
                    const radius = 30 + (note.velocity / 127) * 40; // Larger than original

                    // Create radial gradient for soft blended edges
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${opacity})`);
                    gradient.addColorStop(0.7, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${opacity * 0.5})`);
                    gradient.addColorStop(1, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Note name
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.font = '14px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(colorEngine.getNoteName(note.midiNote), x, y);
                });
            }

            renderPercussion(lane, ctx, canvas, now) {
                const bgColor = this.theme === 'dark' ? '#000' : '#fff';
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                lane.activeNotes.forEach((note) => {
                    const age = note.releaseTime ? (now - note.releaseTime) : (now - note.startTime);
                    const burstDuration = 300; // ms
                    
                    if (age > burstDuration) {
                        lane.activeNotes.delete(note.midiNote);
                        return;
                    }

                    const progress = age / burstDuration;
                    const opacity = 1 - progress;
                    const x = (note.midiNote / 127) * canvas.width;
                    const y = canvas.height / 2;
                    
                    // Burst size based on velocity
                    const maxRadius = 50 + (note.velocity / 127) * 100;
                    const currentRadius = maxRadius * progress;

                    // Radiating particles
                    const particleCount = Math.floor(8 + (note.velocity / 127) * 16);
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (i / particleCount) * Math.PI * 2;
                        const px = x + Math.cos(angle) * currentRadius;
                        const py = y + Math.sin(angle) * currentRadius;
                        
                        ctx.beginPath();
                        ctx.arc(px, py, 3 + (note.velocity / 127) * 5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${opacity})`;
                        ctx.fill();
                    }

                    // Central flash
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, currentRadius * 0.5);
                    gradient.addColorStop(0, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${opacity})`);
                    gradient.addColorStop(1, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, currentRadius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            renderCombination(now) {
                const ctx = this.combinationCtx;
                const canvas = this.combinationCanvas;
                const bgColor = this.theme === 'dark' ? '#000' : '#fff';
                
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) * 0.45;

                // Collect all active notes from all lanes
                const allNotes = [];
                
                this.lanes.forEach((lane, laneIndex) => {
                    lane.activeNotes.forEach((note, midiNote) => {
                        let opacity = 1.0;
                        let shouldRemove = false;
                        
                        if (note.releaseTime) {
                            const elapsed = now - note.releaseTime;
                            opacity = Math.max(0, 1 - elapsed / this.decayTime);
                            
                            if (opacity <= 0) {
                                shouldRemove = true;
                            }
                        }
                        
                        if (!shouldRemove) {
                            allNotes.push({ 
                                ...note, 
                                opacity,
                                laneIndex 
                            });
                        } else {
                            setTimeout(() => {
                                lane.activeNotes.delete(midiNote);
                                this.updateNoteCount(laneIndex);
                            }, 0);
                        }
                    });
                });

                // Draw orbital rings for each note
                allNotes.forEach((note, index) => {
                    // Calculate orbital parameters
                    const noteAngle = (note.midiNote / 127) * Math.PI * 2;
                    const velocityFactor = (note.velocity / 127);
                    const radius = maxRadius * (0.3 + velocityFactor * 0.7); // Velocity affects orbit size
                    
                    // Ring thickness based on velocity
                    const thickness = 3 + velocityFactor * 12;
                    
                    // Create gradient for the orbital ring
                    ctx.save();
                    ctx.globalAlpha = note.opacity;
                    
                    // Draw the orbital ellipse/circle
                    ctx.beginPath();
                    ctx.ellipse(
                        centerX, 
                        centerY, 
                        radius, 
                        radius * 0.95, // Slight ellipse for visual interest
                        noteAngle, // Rotation based on pitch
                        0, 
                        Math.PI * 2
                    );
                    
                    // Stroke with color
                    ctx.strokeStyle = `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${note.opacity * 0.8})`;
                    ctx.lineWidth = thickness;
                    ctx.stroke();
                    
                    // Add inner glow effect
                    ctx.beginPath();
                    ctx.ellipse(
                        centerX, 
                        centerY, 
                        radius - thickness/2, 
                        radius * 0.95 - thickness/2, 
                        noteAngle,
                        0, 
                        Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${note.opacity * 0.3})`;
                    ctx.lineWidth = thickness * 0.5;
                    ctx.stroke();
                    
                    // Draw a glowing dot at the "top" of each orbit
                    const dotX = centerX + Math.cos(-Math.PI / 2 + noteAngle) * radius;
                    const dotY = centerY + Math.sin(-Math.PI / 2 + noteAngle) * radius;
                    
                    const dotRadius = 4 + velocityFactor * 8;
                    const gradient = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, dotRadius * 2);
                    gradient.addColorStop(0, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${note.opacity})`);
                    gradient.addColorStop(0.5, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${note.opacity * 0.5})`);
                    gradient.addColorStop(1, `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, dotRadius * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Solid center dot
                    ctx.fillStyle = `rgba(${note.color.r}, ${note.color.g}, ${note.color.b}, ${note.opacity})`;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
                
                // Draw central nucleus
                if (allNotes.length > 0) {
                    const nucleusRadius = 8;
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, nucleusRadius * 3);
                    
                    if (this.theme === 'dark') {
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    } else {
                        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
                        gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.4)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, nucleusRadius * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Solid center
                    ctx.fillStyle = this.theme === 'dark' ? '#fff' : '#000';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, nucleusRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Center text when no notes
                if (allNotes.length === 0) {
                    ctx.fillStyle = this.theme === 'dark' ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Play some notes...', centerX, centerY);
                }
            }

            animate() {
                const now = performance.now();

                if (this.viewMode === 'lanes') {
                    this.lanes.forEach((lane, index) => {
                        const ctx = lane.ctx;
                        const canvas = lane.canvas;

                        switch (lane.instrument) {
                            case 'bass':
                                this.renderBass(lane, ctx, canvas, now);
                                break;
                            case 'chords':
                                this.renderChords(lane, ctx, canvas, now);
                                break;
                            case 'melody':
                                this.renderMelody(lane, ctx, canvas, now);
                                break;
                            case 'percussion':
                                this.renderPercussion(lane, ctx, canvas, now);
                                break;
                        }
                    });
                } else {
                    this.renderCombination(now);
                }

                requestAnimationFrame(() => this.animate());
            }

            showNoMidiMessage() {
                document.getElementById('no-midi-message').classList.remove('hidden');
            }

            hideNoMidiMessage() {
                document.getElementById('no-midi-message').classList.add('hidden');
            }
        }

        // Initialize visualizer
        const visualizer = new MIDIVisualizer();

        // Control panel toggle
        let controlsVisible = true;
        function toggleControls() {
            controlsVisible = !controlsVisible;
            const panel = document.getElementById('control-panel');
            const container = document.getElementById('canvas-container');
            const button = document.getElementById('control-toggle');
            
            if (controlsVisible) {
                panel.classList.remove('collapsed');
                container.classList.add('show-controls');
                button.textContent = '‚öô Settings';
            } else {
                panel.classList.add('collapsed');
                container.classList.remove('show-controls');
                button.textContent = '‚öô Show Settings';
            }
        }

        // Start with controls visible
        window.addEventListener('load', () => {
            document.getElementById('canvas-container').classList.add('show-controls');
        });

        // Theme switching
        function setTheme(theme) {
            visualizer.theme = theme;
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
        }

        // View mode switching
        function setViewMode(mode) {
            visualizer.viewMode = mode;
            document.getElementById('canvas-container').className = mode === 'combination' ? 'combination-mode' : '';
            
            // Update button states
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        // Info modal
        function toggleInfo() {
            document.getElementById('info-modal').classList.toggle('visible');
        }

        document.getElementById('info-modal').addEventListener('click', (e) => {
            if (e.target.id === 'info-modal') toggleInfo();
        });

        console.log('Enhanced Newton\'s Chromatic MIDI Visualizer loaded');
    </script>
</body>
</html>
