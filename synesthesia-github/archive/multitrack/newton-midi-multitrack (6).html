<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton MIDI Visualizer - Lightweight</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            padding: 10px 15px;
            background: rgba(0,0,0,0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        #title { font-size: 20px; font-weight: bold; }
        #controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        .btn:hover { opacity: 0.8; }
        #status { background: #dc2626; color: white; }
        #status.connected { background: #16a34a; }
        #modeBtn { background: #0ea5e9; color: white; }
        #guideBtn { background: #9333ea; color: white; }
        #visualCanvas {
            flex: 1;
            display: block;
            width: 100%;
            background: #16213e;
        }
        #pianoContainer {
            height: 140px;
            background: rgba(0,0,0,0.4);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding: 10px;
        }
        #pianoCanvas {
            display: block;
        }
        #info {
            padding: 8px;
            text-align: center;
            font-size: 11px;
            background: rgba(0,0,0,0.4);
        }
        #guide {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 2px solid #9333ea;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        #guide.show { display: block; }
        #guide h3 { margin-bottom: 15px; color: #9333ea; }
        #guide p { margin-bottom: 10px; font-size: 13px; line-height: 1.5; }
        #guide .close {
            float: right;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="title">Newton MIDI Visualizer - Lightweight</div>
            <div id="controls">
                <div id="status" class="btn">‚óè Disconnected</div>
                <button id="modeBtn" class="btn">üéöÔ∏è Lanes</button>
                <button id="guideBtn" class="btn">üìñ Guide</button>
            </div>
        </div>
        <canvas id="visualCanvas"></canvas>
        <div id="pianoContainer">
            <canvas id="pianoCanvas"></canvas>
        </div>
        <div id="info">
            <span id="trackCount">No tracks connected</span> ‚Ä¢ 
            Velocity affects size & saturation ‚Ä¢ 
            Newton's color wheel C0-C10
        </div>
    </div>

    <div id="guide">
        <button class="close" onclick="document.getElementById('guide').classList.remove('show')">‚úï Close</button>
        <h3>How It Works</h3>
        <p><strong>Octave ‚Üí Brightness:</strong> Lower octaves (C0) are dark, higher octaves (C10) are bright.</p>
        <p><strong>Velocity ‚Üí Size & Saturation:</strong> Soft playing = small, pastel circles. Hard playing = large, vivid circles.</p>
        <p><strong>Note ‚Üí Color:</strong> Each note has its own Newton color (D=Red, E=Orange, F=Yellow, G=Green, A=Blue, B=Indigo, C=Violet).</p>
        <p><strong>Lanes Mode:</strong> Each MIDI track in its own horizontal lane.</p>
        <p><strong>Layers Mode:</strong> All tracks combined with depth blur effect.</p>
        <hr style="margin: 15px 0; border-color: #444;">
        <p><strong>Logic Pro Setup:</strong></p>
        <p>1. Open Audio MIDI Setup ‚Üí Create multiple IAC buses</p>
        <p>2. In Logic, route each track to different IAC buses</p>
        <p>3. Press Play or Record-enable tracks to send MIDI</p>
    </div>

    <script>
        // Newton's color wheel
        const NEWTON = [
            [148, 0, 211], [204, 0, 102], [255, 0, 0], [255, 69, 0],
            [255, 140, 0], [255, 255, 0], [127, 255, 0], [0, 255, 0],
            [0, 128, 255], [0, 0, 255], [75, 0, 130], [139, 0, 255]
        ];

        // State
        let mode = 'lanes';
        let devices = [];
        let activeNotes = {}; // trackIdx -> {note: vel}
        let particles = {}; // trackIdx -> [{...}]
        let lastFrame = 0;

        // Canvas
        const vc = document.getElementById('visualCanvas');
        const vctx = vc.getContext('2d', { alpha: false });
        const pc = document.getElementById('pianoCanvas');
        const pctx = pc.getContext('2d');

        function resize() {
            vc.width = vc.offsetWidth;
            vc.height = vc.offsetHeight;
            pc.width = 1000;
            pc.height = 120;
        }
        resize();
        window.addEventListener('resize', resize);

        // MIDI
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(access => {
                const inputs = Array.from(access.inputs.values());
                devices = inputs;

                if (inputs.length > 0) {
                    document.getElementById('status').textContent = `‚úì ${inputs.length} Track(s)`;
                    document.getElementById('status').classList.add('connected');
                    document.getElementById('trackCount').textContent = `${inputs.length} track(s) connected`;
                    
                    inputs.forEach((input, idx) => {
                        activeNotes[idx] = {};
                        particles[idx] = [];
                        input.onmidimessage = (m) => midi(m, idx);
                    });
                } else {
                    document.getElementById('status').textContent = '‚úó No MIDI';
                }
            });
        }

        function midi(msg, idx) {
            const [cmd, note, vel] = msg.data;
            const on = cmd >= 144 && cmd <= 159 && vel > 0;
            const off = (cmd >= 128 && cmd <= 143) || (cmd >= 144 && cmd <= 159 && vel === 0);

            if (on) {
                activeNotes[idx][note] = vel;
                
                // Add particle (simplified - no blur, no shadows)
                const oct = Math.floor(note / 12) - 1;
                const n = note % 12;
                const bright = Math.max(0.15, oct / 10);
                const sat = vel / 127;
                const [r, g, b] = NEWTON[n];
                
                particles[idx].push({
                    x: note / 127,
                    y: 0,
                    s: 10 + (vel / 127) * 25, // size
                    c: `rgb(${r*bright*sat + 255*(1-sat)*bright},${g*bright*sat + 255*(1-sat)*bright},${b*bright*sat + 255*(1-sat)*bright})`,
                    t: 0,
                    m: 1500 // max time (reduced from 2000)
                });
                
                // Limit particles per track
                if (particles[idx].length > 20) particles[idx].shift();
                
            } else if (off) {
                delete activeNotes[idx][note];
            }
        }

        // Animation (30fps to reduce CPU)
        function draw(time) {
            const dt = time - lastFrame;
            
            // Only update every ~33ms (30fps)
            if (dt < 33) {
                requestAnimationFrame(draw);
                return;
            }
            lastFrame = time;

            // Clear with solid color (faster than gradient)
            vctx.fillStyle = '#16213e';
            vctx.fillRect(0, 0, vc.width, vc.height);

            if (mode === 'lanes') {
                const n = Object.keys(particles).length || 1;
                const h = vc.height / n;

                Object.entries(particles).forEach(([idx, ps], i) => {
                    const ly = i * h;
                    
                    // Lane divider
                    vctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    vctx.strokeRect(0, ly, vc.width, h);

                    // Particles (no blur, no shadow for performance)
                    for (let j = ps.length - 1; j >= 0; j--) {
                        const p = ps[j];
                        p.t += dt;
                        if (p.t >= p.m) {
                            ps.splice(j, 1);
                            continue;
                        }

                        p.y = p.t / p.m;
                        const a = 1 - p.y;
                        vctx.globalAlpha = a;
                        vctx.fillStyle = p.c;
                        vctx.beginPath();
                        vctx.arc(p.x * vc.width, ly + p.y * h, p.s / 2, 0, 6.28);
                        vctx.fill();
                    }
                    vctx.globalAlpha = 1;

                    // Label
                    vctx.fillStyle = 'rgba(255,255,255,0.4)';
                    vctx.font = '11px Arial';
                    vctx.fillText(`T${parseInt(idx) + 1}`, 5, ly + 15);
                });
            } else {
                // Layers mode (simplified)
                Object.entries(particles).forEach(([idx, ps]) => {
                    const blur = parseInt(idx) * 2 + 3;
                    
                    for (let j = ps.length - 1; j >= 0; j--) {
                        const p = ps[j];
                        p.t += dt;
                        if (p.t >= p.m) {
                            ps.splice(j, 1);
                            continue;
                        }

                        p.y = p.t / p.m;
                        const a = (1 - p.y) * Math.max(0.5, 1 - parseInt(idx) * 0.15);
                        vctx.globalAlpha = a;
                        vctx.fillStyle = p.c;
                        
                        // Simple blur effect using multiple circles (cheaper than filter)
                        for (let k = 0; k < blur; k++) {
                            vctx.beginPath();
                            vctx.arc(p.x * vc.width, p.y * vc.height, (p.s + k) / 2, 0, 6.28);
                            vctx.fill();
                        }
                    }
                    vctx.globalAlpha = 1;
                });
            }

            piano();
            requestAnimationFrame(draw);
        }

        function piano() {
            pctx.clearRect(0, 0, pc.width, pc.height);
            
            const kw = pc.width / 75;
            const wh = pc.height;
            const bh = wh * 0.6;

            // White keys
            let wi = 0;
            for (let oct = 0; oct <= 10; oct++) {
                for (let n = 0; n < 12; n++) {
                    if (oct === 10 && n > 0) break;
                    if ([1, 3, 6, 8, 10].includes(n)) continue;

                    const midi = (oct + 1) * 12 + n;
                    let act = false, vel = 127;
                    
                    Object.values(activeNotes).forEach(notes => {
                        if (notes[midi]) { act = true; vel = Math.max(vel, notes[midi]); }
                    });

                    const bright = oct / 10;
                    const sat = vel / 127;
                    const [r, g, b] = NEWTON[n];
                    const col = `rgb(${r*bright*sat + 255*(1-sat)*bright},${g*bright*sat + 255*(1-sat)*bright},${b*bright*sat + 255*(1-sat)*bright})`;

                    const x = wi * kw;
                    pctx.fillStyle = col;
                    pctx.fillRect(x, 0, kw - 1, wh);
                    
                    if (act) {
                        pctx.strokeStyle = 'white';
                        pctx.lineWidth = 2;
                        pctx.strokeRect(x, 0, kw - 1, wh);
                    }

                    pctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    pctx.lineWidth = 1;
                    pctx.strokeRect(x, 0, kw - 1, wh);

                    wi++;
                }
            }

            // Black keys
            wi = 0;
            for (let oct = 0; oct <= 10; oct++) {
                for (let n = 0; n < 12; n++) {
                    if (oct === 10 && n > 0) break;
                    const black = [1, 3, 6, 8, 10].includes(n);
                    
                    if (!black) { wi++; continue; }

                    const midi = (oct + 1) * 12 + n;
                    let act = false, vel = 127;
                    
                    Object.values(activeNotes).forEach(notes => {
                        if (notes[midi]) { act = true; vel = Math.max(vel, notes[midi]); }
                    });

                    const bright = oct / 10;
                    const sat = vel / 127;
                    const [r, g, b] = NEWTON[n];
                    const col = `rgb(${r*bright*sat + 255*(1-sat)*bright},${g*bright*sat + 255*(1-sat)*bright},${b*bright*sat + 255*(1-sat)*bright})`;

                    const x = wi * kw - kw * 0.3;
                    pctx.fillStyle = col;
                    pctx.fillRect(x, 0, kw * 0.6, bh);
                    
                    if (act) {
                        pctx.strokeStyle = 'white';
                        pctx.lineWidth = 2;
                        pctx.strokeRect(x, 0, kw * 0.6, bh);
                    }
                }
            }
        }

        // Controls
        document.getElementById('modeBtn').onclick = () => {
            mode = mode === 'lanes' ? 'layers' : 'lanes';
            document.getElementById('modeBtn').textContent = mode === 'lanes' ? 'üéöÔ∏è Lanes' : 'üé≠ Layers';
        };

        document.getElementById('guideBtn').onclick = () => {
            document.getElementById('guide').classList.add('show');
        };

        // Start
        requestAnimationFrame(draw);
    </script>
</body>
</html>